# Тестирование

Здесь описаны последовательность ввода параметров и запуск программы на предложенном примере.

1.	Загрузите в рабочую область **Matlab** файл `GroundTruthModel.mat` из папки `demos` или любое другое одноцветное изображение и назовём его **RealQ**. Коэффициенты Цернике для предложенного примера: <br>

    **С1 = 0,2; С2 = -0,1; С3 = -0,1; С4 = -0,1; С5 = 0,1; С7 = -0,1; С8 = 0,15;
С12 = 0,15; С23 = -0,05.**

2.	Зададим параметры **M** – дискретизация выходного зрачка; **KC0** – количество восстанавливаемых коэффициентов Цернике; **С0Start** – начальное приближение коэффициентов Цернике, пример: <br>

    `M = 50; KC0 = 30; C0Start = zeros(KC0,1);`

3.	После этого рассчитаем сами полиномы Цернике: <br>

    `[VectorPolinoms,R] = Polinoms (M,KC0);`

    где **VectorPolinoms** – это вектор полиномов Цернике, **R** – задаёт форму выходного зрачка, реализован только круглый зрачок без перекрытия.
    Если есть необходимость, то возможно визуализировать волновой фронт: <br>

    `Front = WaveFront(VectorPolinoms,R,M,C0Start);`<br>
    `surf(Front)`

4.	Зададим параметры **N** – дискретизация в плоскости изображения; **Dp** – диаметр выходного зрачка; **z** – расстояние до плоскости изображения, отсчитывается от главной плоскости системы; **wave** – длина волны излучения; **step** – размер пикселя приёмника излучения; **F** – фокусное расстояние, и положим их в вектор **SetDirect**, пример (все значения в метрах): <br>

    `N = 100; Dp = 300*10^(-3); z = 6005*10^(-3); wave = 0.6328*10^(-6); step = 3*10^(-6); F = 6000*10^(-3);`<br>
    `SetDirect = [M, N, Dp, z, wave, step, F];`

    Также зададим **Norm** – максимум на изображении или динамический диапазон и **Noise** – матрица шума, пример: <br>

    `Norm = 240; Noise = round(2*rand(N, N));`

    Если есть необходимость, то возможно визуализировать распределение интенсивности:
    
    `I = DirectTask(C0Start, VectorPolinoms, R, SetDirect);`<br>
    `Q = Model(I, Norm, Noise);`<br>
    `imshow(Q, [0, 255])`<br>

5.	Зададим параметры **Function** – функция, глобальный минимум которой будем искать; **MaxIters** – число итераций поиска; **MaxStep** – максимальный шаг приращения коэффициента Цернике; **LeftBord** – минимально допустимое значения коэффициента Цернике; **RightBord** – максимально допустимое значения коэффициента Цернике; **MSD** – пороговое значение СКО реального и рассчитанного изображения; **ErrorCoeff** – граничное значение приращения коэффициентов Цернике, и поместим их в вектор **SetInverse**, пример: <br>
    
    `Function = @LikelihoodFunction;` <br>
    `MaxIters = 20; MaxStep = 0.2; LeftBord = -1; RightBord = 1; MSD = 3; ErrorCoef = 10^(-7);` <br>
    `SetInverse = [MaxIters, MaxStep, LeftBord, RightBord, MSD, ErrorCoef];` <br>
    
6.	Вызов основной функции, приблизительное время расчёта от ***30 минут до 2 часов***: <br>

    `[C0Inv, Iters, MSDInv] = BFGS (C0Start, Function, SetInverse, VectorPolinoms, R, SetDirect, Norm, Noise, KC0, RealQ);` <br>

До расчёта **MSD** составляет **37,27**.<br>
В результате первого расчёта получили **MSD = 6,46** и **Iters = 21**, т.е. остановились из-за достижения предела по итерациям. Выполним второй раз используя рассчитанные коэффициенты **C0Inv** вместо **C0Start**.<br>
В результате второго подхода получим **MSD = 2,66** и **Iters = 3**, т.е. мы достигли желаемых **MSD < 3**. Теперь Уменьшим **MSD** до нуля **MSD = 0** и запустим завершающую итерацию, также используя рассчитанные коэффициенты **C0Inv** вместо **C0Start**.<br>
И в результате завершающего прохода получили **MSD = 1,13** и **Iters = 21**. По итогу погрешность определения ***коэффициентов Цернике*** составила не более **2ꞏ10^(-3)**.

## Замечания

В этой папке находится файл `RestoredModel.mat`, который является результатом расчёта по выше описанному алгоритму.


В вашем случае значения **СКО (MSD)** могут отличаться, т.к. матрица шума задаётся на основе псевдослучайного алгоритма **rand** **(Noise = round(2*rand(N,N)))**.


В некоторых редких случаях алгоритм может не сойтись, т.е. после **20** итераций **MSD** будет больше **20-30** пикселей. В этом случае рекомендуется заново определить матрицу шума **Noise** и повторить расчёт.

