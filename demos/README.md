# Тестирование

Здесь описаны последовательность ввода параметров и запуск программы на предложенном примере.

1.	Загрузите в рабочую область **Matlab** файл `GroundTruthModel.mat` из папки `demos` или любое другое одноцветное изображение и назовём его **RealQ**. Коэффициенты Цернике для предложенного примера: <br>

    |     C_01    |    C_02    |    C_03     |     C_04    |    C_05    |    C_06     |    C_07    |    C_08    |    C_09     |    C_10     |
    | :---------: | :--------: | :---------: | :---------: | :--------: | :---------: | :--------: | :--------: | :---------: | :---------: |
    | **-0.1252** | **0.0642** | **-0.0662** | **0.2012**  | **0.1108** | **0.0073**  | **0.0391** | **0.0431** | **-0.0622** | **0.0123**  |
    |  **C_11**  |  **C_12**  |  **C_13**   |   **C_14**  |  **C_15**  |  **C_16**   |  **C_17**   |  **C_18**  |  **C_19**   |  **C_20**   |
    | **0.1253** | **0.0896** | **-0.0719** | **0.0007**  | **0.0638** | **-0.0024** | **-0.0348** | **0.0080** | **-0.0256** | **-0.0149** |

2.	Зададим параметры **M** – дискретизация выходного зрачка; **KC0** – количество восстанавливаемых коэффициентов Цернике; **С0Start** – начальное приближение коэффициентов Цернике, пример: <br>

    `M = 50; KC0 = 20; C0Start = zeros(KC0,1);`

3.	После этого рассчитаем сами полиномы Цернике: <br>

    `[VectorPolinoms,R] = Polinoms (M,KC0);`

    где **VectorPolinoms** – это вектор полиномов Цернике, **R** – задаёт форму выходного зрачка, реализован только круглый зрачок без перекрытия.
    Если есть необходимость, то возможно визуализировать волновой фронт: <br>

    `Front = WaveFront(VectorPolinoms,R,M,C0Start);`<br>
    `surf(Front)`

4.	Зададим параметры **N** – дискретизация в плоскости изображения; **Dp** – диаметр выходного зрачка; **z** – расстояние до плоскости изображения, отсчитывается от главной плоскости системы; **wave** – длина волны излучения; **step** – размер пикселя приёмника излучения; **F** – фокусное расстояние, и положим их в вектор **SetDirect**, пример (все значения в метрах): <br>

    `N = 100; Dp = 300*10^(-3); z = 6005*10^(-3); wave = 0.6328*10^(-6); step = 3*10^(-6); F = 6000*10^(-3);`<br>
    `SetDirect = [M, N, Dp, z, wave, step, F];`

    Также зададим **Norm** – максимум на изображении или динамический диапазон и **Noise** – матрица шума, пример: <br>

    `Norm = 255; Noise = 0;`

    Если есть необходимость, то возможно визуализировать распределение интенсивности:
    
    `I = DirectTask(C0Start, VectorPolinoms, R, SetDirect);`<br>
    `Q = Model(I, Norm, Noise);`<br>
    `imshow(Q, [0, 255])`<br>

5.	Зададим параметры **Function** – функция, глобальный минимум которой будем искать; **MaxIters** – число итераций поиска; **MaxStep** – максимальный шаг приращения коэффициента Цернике; **LeftBord** – минимально допустимое значения коэффициента Цернике; **RightBord** – максимально допустимое значения коэффициента Цернике; **MSD** – пороговое значение СКО реального и рассчитанного изображения; **ErrorCoeff** – граничное значение приращения коэффициентов Цернике, и поместим их в вектор **SetInverse**, пример: <br>
    
    `Function = @LikelihoodFunction;` <br>
    `MaxIters = 20; MaxStep = 0.2; LeftBord = -1; RightBord = 1; MSD = 3; ErrorCoef = 10^(-7);` <br>
    `SetInverse = [MaxIters, MaxStep, LeftBord, RightBord, MSD, ErrorCoef];` <br>
    
6.	Вызов основной функции, приблизительное время расчёта от ***30 минут до 2 часов***: <br>

    `[C0Inv, Iters, MSDInv] = BFGS (C0Start, Function, SetInverse, VectorPolinoms, R, SetDirect, Norm, Noise, KC0, RealQ);` <br>

До расчёта **MSD** составляет **xx,xx**.<br>
В результате первого расчёта получили **MSD = xx,xx** и **Iters = xx**, т.е. остановились из-за достижения предела по итерациям. Выполним второй раз используя рассчитанные коэффициенты **C0Inv** вместо **C0Start**.<br>
В результате второго подхода получим **MSD = xx,xx** и **Iters = xx**, т.е. мы достигли желаемых **MSD < 3**. Теперь Уменьшим **MSD** до нуля **MSD = 0** и запустим завершающую итерацию, также используя рассчитанные коэффициенты **C0Inv** вместо **C0Start**.<br>
И в результате завершающего прохода получили **MSD = xx,xx** и **Iters = xx**. По итогу погрешность определения ***коэффициентов Цернике*** составила не более **xꞏ10^(-3)**.

## Замечания

В этой папке находится файл `RestoredModel.mat`, который является результатом расчёта по выше описанному алгоритму.

Во многих случаях алгоритм может не сойтись, если начинать из нулевых коэффициентов Цернике, т.е. после **20** итераций **MSD** будет больше **20-30** пикселей. В этом случае рекомендуется... $K_11$

