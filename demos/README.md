# Тестирование

Здесь описаны последовательность ввода параметров и запуск программы на предложенном примере.

1.	Загрузите в рабочую область **Matlab** файл `GroundTruthModel.mat` из папки `demos` или любое другое одноцветное изображение и назовём его **RealQ**. Коэффициенты Цернике для предложенного примера: <br>

    |   $C_{01}$  |  $C_{02}$  |  $C_{03}$   |   $C_{04}$  |  $C_{05}$  |  $C_{06}$   |  $C_{07}$  |  $C_{08}$  |  $C_{09}$   |  $C_{10}$   |
    | :---------: | :--------: | :---------: | :---------: | :--------: | :---------: | :--------: | :--------: | :---------: | :---------: |
    | **-0.1252** | **0.0642** | **-0.0662** | **0.2012**  | **0.1108** | **0.0073**  | **0.0391** | **0.0431** | **-0.0622** | **0.0123**  |
    |  $C_{11}$   |  $C_{12}$  |  $C_{13}$   |   $C_{14}$  |  $C_{15}$  |  $C_{16}$   |  $C_{17}$  |  $C_{18}$  |  $C_{19}$   |  $C_{20}$   |
    | **0.1253**  | **0.0896** | **-0.0719** | **0.0007**  | **0.0638** | **-0.0024** | **-0.0348**| **0.0080** | **-0.0256** | **-0.0149** |

2.	Зададим параметры **M** – дискретизация выходного зрачка; **KC0** – количество восстанавливаемых коэффициентов Цернике; **С0Start** – начальное приближение коэффициентов Цернике, пример: <br>

    `M = 50; KC0 = 20; C0Start = zeros(KC0,1);`

    Во многих случаях начальное приближение нулевыми коэффициентами приведёт к попаданию в локальный минимум. Поэтому, если алгоритм не сходится необходимо перезадать начальное приближение (*см. замечания*).

3.	После этого рассчитаем сами полиномы Цернике: <br>

    `[VectorPolinoms,R] = Polinoms (M,KC0);`

    где **VectorPolinoms** – это вектор полиномов Цернике, **R** – задаёт форму выходного зрачка, реализован только круглый зрачок без перекрытия.
    Если есть необходимость, то возможно визуализировать волновой фронт: <br>

    `Front = WaveFront(VectorPolinoms,R,M,C0Start);`<br>
    `surf(Front)`

4.	Зададим параметры **N** – дискретизация в плоскости изображения; **Dp** – диаметр выходного зрачка; **z** – расстояние до плоскости изображения, отсчитывается от главной плоскости системы; **wave** – длина волны излучения; **step** – размер пикселя приёмника излучения; **F** – фокусное расстояние, и положим их в вектор **SetDirect**, пример (все значения в метрах): <br>

    `N = 100; Dp = 300*10^(-3); z = 6005*10^(-3); wave = 0.6328*10^(-6); step = 3*10^(-6); F = 6000*10^(-3);`<br>
    `SetDirect = [M, N, Dp, z, wave, step, F];`

    Также зададим **Norm** – максимум на изображении или динамический диапазон и **Noise** – матрица шума, пример: <br>

    `Norm = 255; Noise = 0;`

    Если есть необходимость, то возможно визуализировать распределение интенсивности:
    
    `I = DirectTask(C0Start, VectorPolinoms, R, SetDirect);`<br>
    `Q = Model(I, Norm, Noise);`<br>
    `imshow(Q, [0, 255])`<br>

5.	Зададим параметры **Function** – функция, глобальный минимум которой будем искать; **MaxIters** – число итераций поиска; **MaxStep** – максимальный шаг приращения коэффициента Цернике; **LeftBord** – минимально допустимое значения коэффициента Цернике; **RightBord** – максимально допустимое значения коэффициента Цернике; **MSD** – пороговое значение СКО реального и рассчитанного изображения; **ErrorCoeff** – граничное значение приращения коэффициентов Цернике, и поместим их в вектор **SetInverse**, пример: <br>
    
    `Function = @LikelihoodFunction;` <br>
    `MaxIters = 20; MaxStep = 0.2; LeftBord = -1; RightBord = 1; MSD = 3; ErrorCoef = 10^(-7);` <br>
    `SetInverse = [MaxIters, MaxStep, LeftBord, RightBord, MSD, ErrorCoef];` <br>
    
6.	Вызов основной функции, приблизительное время расчёта от ***30 минут до 2 часов***: <br>

    `[C0Inv, Iters, MSDInv] = BFGS (C0Start, Function, SetInverse, VectorPolinoms, R, SetDirect, Norm, Noise, KC0, RealQ);` <br>

До расчёта **MSD** составляет **44,23**.<br>

В результате первого расчёта получили **MSD = 9,18** и **Iters = 21**, т.е. остановились из-за достижения предела по итерациям. Выполним второй раз используя рассчитанные коэффициенты **C0Inv** вместо **C0Start**.<br>

В результате второго подхода получим **MSD = 2,54** и **Iters = 6**, т.е. мы достигли желаемых **MSD < 3**. Теперь Уменьшим **MSD** до нуля **MSD = 0** и запустим завершающую итерацию, также используя рассчитанные коэффициенты **C0Inv** вместо **C0Start**.<br>

В результате третьего прохода получили **MSD = 0,32** и **Iters = 21**.

Можно попробовать продолжить расчёт, но алгоритм будет медленно сходится к какому-то значению. <br>
В результате завершающего прохода получили **MSD = 0,30** и **Iters = 21**.

По итогу погрешность определения каждого ***коэффициента Цернике*** составила не более **0.0006**, т.е. $\bigtriangleup C_i \eqslantless 0.0006$.

## Замечания

Во многих случаях алгоритм может не сойтись, если начинать из нулевых коэффициентов Цернике, т.е. после **20** итераций **MSD** будет больше **20-30** пикселей. В этом случае рекомендуется задать приближённые коэффициенты Цернике на основе модели оптической системы. Если нет такой возможности, то можно попробовать задать случайным образом коэффициенты Цернике с разбросом относительно нуля не более **0.1**.
